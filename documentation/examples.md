# DSPL through examples

Here are some examples of DSPL code

## Read a number from a file and write it to another
```R
main: module = {
    # source has fields: path, type, rate
    input: source = {"path_to_file.bin", "i32", 1000}

    # sink has fields: path, type, endianness
    output: sink = {"path_to_file.bin", "i32", "little-endian"}

    # the stream field outputs an event for each value in the file and stops at
    # EOF. The rate is that specified in the source literal
    output.write = input.stream
}

```
All event paths in module (in this case ther is only one: `input -> output`) are
looped until they all run out of events (in this case, when input has been read
through entirely) then the module quits.

The `source` and `sink` type behave similarly to a record, except that the fields
that are visible at initialization and those available at execution are different.

__Source initialization__:
+ `path: [byte]` string representing the path to the source file
+ `type: [byte]` strung representing the type to be read, determines the type of 
the source
+ `rate: i32` the sample rate of the source, only relevant when processing in
prallel

__Source access at run-time__:
+ `path: [byte]` (read-only)
+ `type: i32` (read-only)
+ `rate: i32` (read-only)
+ `c: clock` (read-only) valueless event stream at sample rate
+ `read: <type>` (read-only) current value pointed to in the file, at each event
it is moved forward.
+ `stream: <type>` (read-only) value event stream at sample rate, goes through
the entire list
Sources can be chained by plugging another clock source into them, this will
disable its internal rate and will make it inherit the rate from the source clock.

## How to understand the event system
In DSPL all operations are powered by events, without an event source, nothing
happens. In fact, a DSPL program will quit when there are no more events available.
For example, this statement will do nothing:\
`print("hello world")`\
Instead, a clock source has to be plugged into any chain of operations to produce
outputs:
```R
c: clock = {"fixed", 1000}
c -> print("hello world")
```
This however will print "hello world" 1000 times a second, forever. To print a
single line, it becomes a bit trickier, in fact DSPL is not meant for this more
traditional form of computation, but if you still watn a "hello world", you can
simply quit the module once it has printed once, by using a lambda expression:
```R
c: clock = {"fixed", 1000}
c -> (){ _ -> print("hello world"); quit; }
```
The `_` placeholder is matched to whatever is plugged into the expression from
left to right. Expressions not containing any `_` are not pluggable and thus not
clockable. They will be passively clocked by whatever expression they are called
by. (In practice it just means they don't support the plug operator '`->`')

## Doing some arithmetic
Simple expressions use prefix notation (because this allows very fast execution).
These expressions are equivalent, however the second is encouraged as it is more
readable:
```R
+ / 3 + 4 5 * 6 2
+ (/ 3 (+ 4 5)) (* 6 2)
```
Expressions can also contain identifiers, calls to lambda expressions, ...
Expressions can be "passively clocked":
```R
some_source -> some_identifier
print(+ 1 some_identifier)
```
Will print a line for each event generated by `some_source`, because `some_identifier`
inherits the clock in `some_source` and thus clocks the expression it is in.

This behavior might seem strange, but it comes from the philosophy that clocked
signals are the driving elements, and all constants modify the clocked signals.
Thus we don't care about clocking constants if they're not modifying any signals
and we do care about preserving the clock of a signal from its generation to its
consumption.

But what if two different clock sources are input into the same expression?
Then the two streams of events are merged. If an event arrives at one source while
the other source is between two events, the last value that arrived at the former
source is held (like a sample-and-hold). The resulting event will have a rate equal
to the smallest common multuple of the two input rates. If a different rate is
required the `reclock()` standard library process can be used to re-sample the
output.

## Clocking entire modules and iterators
But what if you want to iterate an operation, within a single clock pulse? (For
example when doing FFT convolution or when dealing with arrays) You can use the 
`iterator()` core function to generate N index events for each incoming event.
For example, let's suppose you need to sum every value in an array:
```R
sum: process = (_: [number]) -> number {
    sum: number;
    i = _ -> iterator(_.size);
    (+ (@ sum 1) _[i])  # this exploits the fact that the @ operator, when trying
                        # to read an uninitialized variable, returns 0
};
```

## Some things DSPL is REALLY good at
So far you might be thinking "wait a minute, why do you purposely make things
complicated with events and the like?" And I do understand your point, until you
see some more specialized uses of DSPL.

Here is an example of a chain of processes:
```R
import wave;    # this standard library includes sources for .wav files
import audio;   # this standard library contains common audio filters
import clock;   # this standard library contains clock modulators
import audio.filters;
import audio.mod;

# inputs and outputs
input: wave_source = {"input.wav", "i24", 44100};
output: wave_sink = {"output.wav", "i24"};
beats: clock = clock.sr_to_bpm(120, input.rate);    # sr_to_bpm produces a clock
                                                    # at a specific bpm from a
                                                    # given sample rate
env: f32 = beats -> audio.mod.env_d(20000, 0.0, 0.5);   # decay envelope with
                                                        # max value, min value
                                                        # and tension. Clock
                                                        # input triggers env.
output.write     = wave.source 
                -> audio.filters.butterworth("LP", env)
                -> (* 2 audio.saturator.tanh(0.5))
                -> audio.effects.delay("tape", <other params>)
                -> audio.effects.reverb("spring",  <other params>)
                -> (* _ 0.5);
```

## Function proposal:
Change the function syntax to the following:
```R
foo: process = (x: int, y: int) -> (z: int, w: int) {
    z = x + y;
    w = x - y;
}

# calling the function:
bar: int = 2;
baz: int = 1;
a: int = 0;
b: int = 0;
(a, b) = foo(bar, baz);

# now I/O is simplified, the toplevel code runs inside a main function. When
# deploying to rust vst, the main takes 2 arguments (l, r) and returns 2 arguments (l, r)
# in the future need for MIDI I/O and other deployment targets will change this
main: process = (l_in: float, r_in: float) -> (l_out: float, r_out: float) {
    # ...
}
```

## Compiled code
For now DSPL is compiled to rust-vst. All functions in dspl are inlined so that
all '@' operators are extracted and converted into the `Effect` struct where
all stateful variables are stored.

## UI components
UI stuff I haven't really thought about. Probably the easiest implementation is
specifying which variables in the code are to be transformed into UI components
rather than variables, by specifying them in the manifest file.

## Manifest file
Eventually I'd like to have a form of manifest file, perhaps in `.toml` format
that specifies optimization level, target platform, UI stuff, Rust embeddings, ...
## Embedding Rust
For ease of development I want to implement a way to embed rust code into DSPL
code. For now I am simply defining a list of reserved function identifiers which
the compiler knows are special cases, but ideally there'd be a way of writing
libraries in Rust and importing them in DSPL code.

## Core Functions
Beside the standard libraries, there is also a set of "core functions" which are
do not need to be imported to be used. These are very basic functionalities like
control structures and host-related stuff.

+ `getsr() -> int`: returns the current sample rate
+ `if_i(cond: bool, then: int, else: int) -> int`: if-then-else for int expressions
+ `if_f(cond: bool, then: float, else: float) -> float`: if_then_else for float expressions
+ `for(start: int, num: int) -> int`: produces num events per incoming event, in
other words any part of the program that use a value which can be traced back to
a for function will be put into a for loop in code generation. The output is an
index. It can be used for list processing or for running parts of the code at
a higher sample rate (oversampling). Any discrepancies in sample rates will be
solved with interpolation (the quality of which can be decided in the manifest)